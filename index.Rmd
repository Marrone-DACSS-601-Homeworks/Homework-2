---
title: An R Markdown document converted from "Copy_of_Applying_Fun_R.ipynb"
output: html_document
---

# Applying functions in R

# reading data

```{r}
linkGit="https://github.com/DACSS-Fundamentals/overview/raw/refs/heads/main/FSI-2023-DOWNLOAD.xlsx" ## code to request a file from a specific link

fragility23=rio::import(file = linkGit) ## code to use the package rio, import the file above and name it 'fragility23'
```

```{r}
str(fragility23) ## code requests the data structure of 'fragility23' to see the types of data in each column
```

## Apply square root function? - Can't apply it to the entire data frame in R

```{r}
sqrt(fragility23[,4:5]) ## code requests the square root of all the values in columns 4 and 5 to show individual output values
```

```{r}
sqrt(fragility23$Total) ## code requests the square root of each value in the total column 
```

```{r}
sqrt(fragility23$Total[1]) ## code requests the square root of the first value in the total column
```

## Applying **sum()**:

```{r}
sum(fragility23[,4:5]) ## code requests the sum of all values in column 4 and 5
```

```{r}
apply(fragility23[,4:5],2,sum) ## code requests the sum of all values in each column 4 and 5 to show as separate totals
```

```{r}
typeof(apply(fragility23[,4:5],2,sum)) ## code requests the data type of the sums of the values in columns 4 and 5. Since it says 'double' and not list, it is a vector
```

```{r}
class(apply(fragility23[,4:5],2,sum)) ## added this one for myself to see the difference between 'typeof' and 'class' for apply to compare to sapply and lapply
```

If you do not see **list**, then it is a vector. ‚è´

```{r}
print(apply(fragility23[,4:5],1,sum)) ## code requests the sum of the values in each row 
```

### Apply by iterating:

```{r}
print(lapply(fragility23[,4:5],sum)) ## code requests the sum for each of the columns 4 and 5 to get a list instead of vectors; can only compute by column
```

Notice output of **lapply**:

```{r}
typeof(lapply(fragility23[,4:5],sum)) ## code requests the data type of the sums for each of the columns, lapply gives us a list
```

```{r}
class(lapply(fragility23[,4:5],sum)) ## code requests the data class of the sums for each of the columns, lapply gives us a list
```

Notice output of **sapply**:

```{r}
print(sapply(fragility23[,4:5],sum)) ## code requests the sum of all values in each column 4 and 5 to show as separate totals; looks very similar to 'apply' function but gives 
```

```{r}
typeof(sapply(fragility23[,4:5],sum)) ## added this one for myself to see the difference between 'typeof' and 'class' for apply to compare to sapply and lapply
```

```{r}
class(sapply(fragility23[,4:5],sum)) ## code requests the data class of the sums for each of the columns 4 and 5
```

Similarly:

```{r}
print(lapply(fragility23[,4:5],sqrt)) ## code requests the square root of each values in columns 4 and 5
```

```{r}
class(lapply(fragility23[,4:5],sqrt)) ## code requests the data class of the square root values and comes out with a list
```

```{r}
typeof(lapply(fragility23[,4:5],sqrt)) ## added this one for myself to see the difference between 'typeof' and 'class' for apply to compare to sapply and lapply
```

```{r}
print(sapply(fragility23[,4:5],sqrt)) ## code requests the square root of each of the values in columns 4 and 5
```

```{r}
class(sapply(fragility23[,4:5],sqrt)) ## code requests the data class of the square root values and comes out with a matrix or array
```

```{r}
typeof(sapply(fragility23[,4:5],sqrt)) ## added this one for myself to see the difference between 'typeof' and 'class' for apply to compare to sapply and lapply
```

Now our own function:

```{r}
theOnesOK = function(DF_country_and_variable) { # input of the function
  variable_values <- DF_country_and_variable[,2] # code is asking for the country column and the variable value chosen in columns
  avg_value <- mean(variable_values, na.rm = TRUE) # find mean mean of the column and ignore missing values
  is_above <- ifelse(variable_values > avg_value, "Above Average", "Below/At Average") # determine if each country's value is above average or below/at average
  DF_country_and_variable$Status <- is_above # create a 'status' column to label each country with the status above
  return(DF_country_and_variable) # return a data frame with 3 columns- country, S1 and status
}
```

```{r}
theOnesOK(fragility23[,c('Country','S1: Demographic Pressures')]) # code creates a list of information from 'fragility23' that includes the columns of 'country' and 'S1: Demographic Pressures' and adds a third column that tells whether the country in above the mean or below/at the mean of S1: Demographic Pressures.
```

**Different function**

```{r}
theOnesOK2 = function(DF, DFvariable, CountryColumn='Country') { # input of the function
  variable_values <- DF[,DFvariable] # in the new data frame, the variable value will be whichever columns chosen
  avg_value <- mean(variable_values, na.rm = TRUE) # find mean mean of the column and ignore missing values
  is_above <- ifelse(variable_values > avg_value, "Above Average", "Below/At Average") # based on the column chosen above, the code requests to determine if each country is above average or below/at average
  newname = paste('Status_on', DFvariable) # code requests to rename the column of the variable to 'status_on_variable name'
  DF[,newname] <- is_above # code requests that the new data frame includes the 'newname' 'status_on' column showing whether each country is 'above average' or 'below/at average'
  return(DF[,c(CountryColumn, newname)]) # code will return a data frame with the country and the status of that country on a variable in comparison to the mean of the column
}
```

**Example below.
# This function differs from 'theOnesOK' in multiple ways. While it still calculates the mean of the column and assigns each country a status, theOnesOK created a new column while theOnesOK2 renamed the column. TheOnesOK2 is also different because it automated the country column.

```{r}
theOnesOK2(fragility23, "S1: Demographic Pressures")
```


**New function**

```{r}
mystery=function(DF,positionsToUse,CountryColumn='Country'){ # input of the function 
  newDF=DF[,c(CountryColumn),drop = FALSE] # create a new data frame with the 'country' column
  average='average' # new column in data frame named 'average'
  newDF[,average]=apply(DF[,positionsToUse],1,mean,na.rm = TRUE) # new data frame to include a new column named 'average' that finds the mean of the 'positions to use' for each country and to ignore missing values
  return(newDF[,c(CountryColumn,average)]) # return data frame with the country column and the average of the columns specified
}
```

```{r}
mystery(fragility23,4:6) # code creates a new data frame with the country as a column and another column that holds the mean of columns 4, 5 and 6.
```
